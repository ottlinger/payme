package com.payme.controller

import com.payme.db.Account
import com.payme.db.Transaction
import com.payme.exception.NoNegativeBalanceAllowedException
import com.payme.exception.NoSameAccountTransfersException
import grails.transaction.Transactional

import static org.springframework.http.HttpStatus.*

// AutoGenerated and enhanced to allow payments and list of transactions per account
@Transactional(readOnly = true)
class TransactionController {
    def transactionService
    def paymentService

    static allowedMethods = [save: "POST", update: "PUT", delete: "DELETE"]

    def index(Integer max) {
        params.max = Math.min(max ?: 10, 100)
        respond Transaction.list(params), model: [transactionInstanceCount: Transaction.count()]
    }

    /**
     * Returns all transactions of a given accountId without paging.
     */
    def list(Long id) {
        def account = Account.findById(id);
        def transactions = Transaction.findAllByOwner(account)
        respond transactions, model: [transactionInstanceCount: transactions.size(), currentBalance: transactionService.getBalance(account), accountName: account.name, accountId: account.id]
    }

    def show(Transaction transactionInstance) {
        respond transactionInstance
    }

    def create() {
        respond new Transaction(params)
    }

    /**
     * Shows the 'Pay some person' view with an empty transaction domain object.
     */
    def pay() {
        flash.message = ''
        respond new Transaction(params)
    }

    /**
     * Upon submit of the payment operation the given transaction is
     * used to populate the underlying paymentService and perform the actual transfer.
     *
     * If everything works fine the list of accounts is rendered, the pay view otherwise.
     */
    @Transactional
    def submit(Transaction transactionInstance) {
        if (transactionInstance == null) {
            notFound()
            return
        }
        log.info "Starting payment ..."

        if (transactionInstance.hasErrors()) {
            respond transactionInstance.errors, view: 'pay'
            return
        }

        try {
            paymentService.book(transactionInstance.owner.name, transactionInstance.partner.name, transactionInstance.amount)
            log.info 'Transaction finished'

            flash.message = 'Transaction finished successfully, check your balances :-)'
            redirect controller: 'account'

        } catch (NoNegativeBalanceAllowedException e) {
            log.error 'No overdraft allowed'

            flash.message = 'Transaction failed - No overdraft allowed. Please choose a lower amount for transfer.'
            respond transactionInstance, view: 'pay'

        } catch (NoSameAccountTransfersException e) {
            log.warn 'You cannot pay yourself.'

            flash.message = 'Transaction failed - You cannot pay yourself. Please choose a different account holder.'
            respond transactionInstance, view: 'pay'
        }
    }

    @Transactional
    def save(Transaction transactionInstance) {
        if (transactionInstance == null) {
            notFound()
            return
        }

        if (transactionInstance.hasErrors()) {
            respond transactionInstance.errors, view: 'create'
            return
        }

        transactionInstance.save flush: true

        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.created.message', args: [message(code: 'transaction.label', default: 'Transaction'), transactionInstance.id])
                redirect transactionInstance
            }
            '*' { respond transactionInstance, [status: CREATED] }
        }
    }

    def edit(Transaction transactionInstance) {
        respond transactionInstance
    }

    @Transactional
    def update(Transaction transactionInstance) {
        if (transactionInstance == null) {
            notFound()
            return
        }

        if (transactionInstance.hasErrors()) {
            respond transactionInstance.errors, view: 'edit'
            return
        }

        transactionInstance.save flush: true

        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.updated.message', args: [message(code: 'Transaction.label', default: 'Transaction'), transactionInstance.id])
                redirect transactionInstance
            }
            '*' { respond transactionInstance, [status: OK] }
        }
    }

    @Transactional
    def delete(Transaction transactionInstance) {

        if (transactionInstance == null) {
            notFound()
            return
        }

        transactionInstance.delete flush: true

        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.deleted.message', args: [message(code: 'Transaction.label', default: 'Transaction'), transactionInstance.id])
                redirect action: "index", method: "GET"
            }
            '*' { render status: NO_CONTENT }
        }
    }

    protected void notFound() {
        request.withFormat {
            form multipartForm {
                flash.message = message(code: 'default.not.found.message', args: [message(code: 'transaction.label', default: 'Transaction'), params.id])
                redirect action: "index", method: "GET"
            }
            '*' { render status: NOT_FOUND }
        }
    }
}
